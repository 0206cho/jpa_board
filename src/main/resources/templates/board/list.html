<!DOCTYPE html>
<!-- ="layout" : templates/layout.html, 즉 layout.html 파일의 경로를 의미
        스프링 부트에서 타임리프는 기본적으로 templates 폴더를 기준으로 HTML 파일을 바라봄. -->
<html lang="ko" xmlns:th="http://www.thymeleaf.org" layout:decorate="layout">

    <!-- list.html의 content에 선언한 HTML로 렌더링 -->
    <th:block layout:fragment="content">

    <!--/* 검색 영역 */-->
    <div class="input-group" id="adv-search">
        <select id="searchType" class="form-control" style="width: 100px;">
            <option value="">전체</option>
            <option value="title">제목</option>
            <option value="content">내용</option>
            <option value="writer">작성자</option>
        </select>
        <input type="text" id="searchKeyword" class="form-control" placeholder="키워드를 입력해 주세요." style="width: 300px;" />
        <button type="button" class="btn btn-primary">
            <span aria-hidden="true" class="glyphicon glyphicon-search"></span>
        </button>
    </div>

    <!--/* 게시글 영역 */-->
    <div class="table-responsive clearfix">
        <table class="table table-hover">
            <thead>
                <tr>
                    <th>번호</th>
                    <th>제목</th>
                    <th>작성자</th>
                    <th>등록일</th>
                    <th>조회 수</th>
                </tr>
            </thead>

            <!--/* 게시글 리스트 Rendering 영역 */-->
            <tbody id="list">

            </tbody>
        </table>
        <div class="btn_wrap text-right">
            <a th:href="@{/board/write}" class="btn btn-primary waves-effect waves-light">Write</a>
        </div>

        <!-- 페이지네이션 Rendering 영역 -->
        <nav>

        </nav>
    </div>
    </th:block>


    <th:block layout:fragment="script">

    <!-- JS 코드에서 타임리프 문법을 사용하기 위해서 선언 후 스크립트 시작과 끝 태그 CDATA로 묶기-->
    <script th:inline="javascript">
	/*<![CDATA[*/

		/**
		 * 페이지 로딩 시점에 한 번만 실행되는 함수
		 */
		window.onload = () => {

			findAll();
		}

		/**
		 * 게시글 리스트 조회 - 게시글 리스트 조회 API 호출
		 */
		 function findAll() {
            // Ajax말고 fetch() 사용 - ajax보다 api 간편하게 호출할 수 있도록 브라우저에서 제공
            /*
                # feat() 함수
                1. 첫 번째 인자로 요청(Request) URL을 전달
                2. 두 번째 인자로 요청(Request) Method, Headers, Body(Data) 등을 전달한다.
                3. 두 번째 인자가 비어있는 경우, 기본적으로 GET Method로 요청한다.
                4. fetch( )는 Promise라는 이름의 객체(Object)를 반환한다.
             */
            // Response는 HTTP 응답 전체를 나타내는 Promise 객체
            // promise의 ok 상태가 true인 경우, 즉 정상적으로 api가 호출된 경우에만 게시글 리스트(json)를 리턴함.
			fetch('/api/boards').then(response => {
				if (response.ok) {
                    // 리턴된 json은 then()안의 json에 담기게 됨
   					return response.json();
				}
			}).then(json => {
				let html = '';  // 게시글 html 저장

				if (!json.length) {
                    // 데이터가 없는 경우
					html = '<td colspan="5">등록된 게시글이 없습니다.</td>';
				} else {
                    // 데이터가 있는 경우, json에 담긴 객체의 길이만큼 html 그림
					json.forEach((obj, idx) => {
                        // ` (백틱) : ${} 표현식으로 데이터 접근할 수 있음 => 데이터나 문자열 연결에 쉬워짐
						html += `
							<tr>
    							<td>${json.length - idx}</td>
    							<td class="text-left">
    								<a href="javascript: void(0);">${obj.title}</a>
    							</td>
    							<td>${obj.writer}</td>
    							<!-- moment().format() : 날짜 데이터 더욱 쉽게 컨트롤러 가능 -->
    							<td>${moment(obj.createdDate).format('YYYY-MM-DD HH:mm:ss')}</td>
    							<td>${obj.hits}</td>
							</tr>
						`;
                        // ( + ) 기호를 사용하던 기존 방식
                        /*
                        html += '<td>'+ obj.title +'</td>';
                        html += '<td>'+ obj.writer +'</td>';
                        html += '<td>'+ obj.hits +'</td>';
                         */
					});
				}

				document.getElementById('list').innerHTML = html;
			});
		}

	/*]]>*/
    </script>
    </th:block>

</html>